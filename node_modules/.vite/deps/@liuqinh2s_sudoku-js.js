import "./chunk-RSJERJUL.js";

// node_modules/@liuqinh2s/sudoku-js/bundle.js
var Direction;
(function(Direction2) {
  Direction2["vertical"] = "vertical";
  Direction2["horizontal"] = "horizontal";
})(Direction || (Direction = {}));
var DancingLinks = class {
  constructor(sudoKu) {
    this.deleteNodes = [];
    this.ans = [];
    this.isAllOne = false;
    this.sudoKu = sudoKu;
  }
  inputMatrix(matrix) {
    const head = this.build(matrix);
    this.timer = new Date().getTime();
    this.dance(head, head.down);
    return this;
  }
  inputSet(X, S) {
    const matrix = this.newMatrix(X, S);
    this.inputMatrix(matrix);
    return this;
  }
  dance(head, p) {
    if (head.right === head || head.down === head) {
      if (this.isAllOne) {
        this.hasAns = true;
        return true;
      } else if (new Date().getTime() - this.timer > 1e3) {
        this.hasAns = false;
        return true;
      } else {
        return false;
      }
    }
    if (!p) {
      const columnHead = this.getMinColumn(head);
      p = this.getRowHead(columnHead.down);
    }
    let res = false;
    while (p !== head) {
      this.ans.push(p.row);
      const matrixWidth = this.getMatrixWidth(head);
      this.isAllOne = matrixWidth === this.getMatrixWidth(p);
      const deleteNodes = this.remove(p, head);
      this.deleteNodes.push(deleteNodes);
      if (this.dance(head)) {
        res = true;
        break;
      }
      this.ans.pop();
      this.recover(this.deleteNodes.pop());
      p = p.down;
    }
    return res;
  }
  build(matrix) {
    this.matrix = matrix;
    const head = newHead();
    const columnHeadArray = newColumnHead(matrix, head);
    const rowHeadArray = newRowHead(matrix, head);
    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[i].length; j++) {
        if (matrix[i][j] == 1) {
          const node = {
            row: i,
            column: j,
            up: columnHeadArray[j].up,
            down: columnHeadArray[j],
            right: rowHeadArray[i],
            left: rowHeadArray[i].left
          };
          rowHeadArray[i].left.right = node;
          rowHeadArray[i].left = node;
          columnHeadArray[j].up.down = node;
          columnHeadArray[j].up = node;
        }
      }
    }
    this.head = head;
    this.columnHeadArray = columnHeadArray;
    this.rowHeadArray = rowHeadArray;
    return head;
    function newHead() {
      const head2 = {
        right: null,
        left: null,
        up: null,
        down: null
      };
      head2.right = head2;
      head2.left = head2;
      head2.up = head2;
      head2.down = head2;
      return head2;
    }
    function newColumnHead(matrix2, head2) {
      const columnHeadArray2 = {};
      for (let i = 0; i < matrix2[0].length; i++) {
        const node = {
          column: i,
          right: head2,
          left: head2.left,
          up: null,
          down: null
        };
        node.up = node;
        node.down = node;
        head2.left.right = node;
        head2.left = node;
        columnHeadArray2[i] = node;
      }
      return columnHeadArray2;
    }
    function newRowHead(matrix2, head2) {
      const rowHeadArray2 = {};
      for (let i = 0; i < matrix2.length; i++) {
        const node = {
          row: i,
          right: null,
          left: null,
          down: head2,
          up: head2.up
        };
        node.right = node;
        node.left = node;
        head2.up.down = node;
        head2.up = node;
        rowHeadArray2[i] = node;
      }
      return rowHeadArray2;
    }
  }
  newMatrix(X, S) {
    let res = [];
    for (let i = 0; i < S.length; i++) {
      let row = new Array(X.length).fill(0);
      for (let j = 0; j < S[i].length; j++) {
        row[X.indexOf(S[i][j])] = 1;
      }
      res.push(row);
    }
    return res;
  }
  getRow(rowHead) {
    const matrixWidth = this.getMatrixWidth(this.head);
    if (matrixWidth < 1) {
      return [];
    }
    let row = new Array(matrixWidth).fill(0);
    let node = rowHead.right;
    while (node !== rowHead) {
      const columnHead = this.getColumnHead(node);
      const index = this.getColumnIndex(columnHead);
      row[index] = 1;
      node = node.right;
    }
    return row;
  }
  getColumn(columnHead) {
    const matrixHeight = this.getMatrixHeight(this.head);
    if (matrixHeight < 1) {
      return [];
    }
    let res = new Array(matrixHeight).fill(0);
    let node = columnHead.down;
    while (node !== columnHead) {
      const rowHead = this.getRowHead(node);
      const index = this.getRowIndex(rowHead);
      res[index] = 1;
      node = node.down;
    }
    return res;
  }
  remove(p, head) {
    const nodes1 = this.removeAllColumn(p);
    const nodes2 = [...nodes1];
    for (let i = 0; i < nodes1.length; i++) {
      if (!nodes1[i].hasOwnProperty("row")) {
        const nodes = this.removeAllRow(nodes1[i]);
        nodes2.push(...nodes);
      }
    }
    return [...new Set(nodes2)];
  }
  removeAllColumn(node) {
    const rowHead = this.rowHeadArray[node.row];
    let p = rowHead;
    const res = [];
    while (true) {
      const deleteNodes = this.removeColumn(p);
      res.push(...deleteNodes);
      p = p.right;
      if (p === rowHead) {
        break;
      }
    }
    return res;
  }
  removeAllRow(node) {
    const columnHead = this.columnHeadArray[node.column];
    let p = columnHead;
    const res = [];
    while (true) {
      const deleteNodes = this.removeRow(p);
      res.push(...deleteNodes);
      p = p.down;
      if (p === node) {
        break;
      }
    }
    return res;
  }
  removeColumn(node) {
    if (!node || !node.hasOwnProperty("column")) {
      return [];
    }
    if (this.isColumnDeleted(node)) {
      return [];
    }
    const columnHead = this.columnHeadArray[node.column];
    let p = columnHead;
    const res = [];
    while (true) {
      if (p.left.right === p && p.right.left === p) {
        p.left.right = p.right;
        p.right.left = p.left;
        res.push(p);
      }
      p = p.down;
      if (p === columnHead) {
        break;
      }
    }
    return res;
  }
  removeRow(node) {
    if (!node || !node.hasOwnProperty("row")) {
      return [];
    }
    if (this.isRowDeleted(node)) {
      return [];
    }
    const rowHead = this.rowHeadArray[node.row];
    let p = rowHead;
    const res = [];
    while (true) {
      if (p.up.down === p && p.down.up === p) {
        p.up.down = p.down;
        p.down.up = p.up;
        res.push(p);
      }
      p = p.right;
      if (p == rowHead) {
        break;
      }
    }
    return res;
  }
  isRowDeleted(node) {
    if (!node || !node.hasOwnProperty("row")) {
      console.error("\u8282\u70B9\u4E0D\u5408\u7406:", node);
    }
    const rowHead = this.rowHeadArray[node.row];
    let p = this.head.down;
    while (p !== this.head) {
      if (p === rowHead) {
        return false;
      }
      p = p.down;
    }
    return true;
  }
  isColumnDeleted(node) {
    if (!node || !node.hasOwnProperty("column")) {
      console.error("\u8282\u70B9\u4E0D\u5408\u7406:", node);
    }
    const columnHead = this.columnHeadArray[node.column];
    let p = this.head.right;
    while (p !== this.head) {
      if (p === columnHead) {
        return false;
      }
      p = p.right;
    }
    return true;
  }
  recover(nodes) {
    for (let i = 0; i < nodes.length; i++) {
      const p = nodes[i];
      p.left.right = p;
      p.right.left = p;
      p.down.up = p;
      p.up.down = p;
    }
  }
  getMinColumn(head) {
    let curNode = head.right;
    let min = this.getLinkedListLength(curNode, Direction.vertical) - 1;
    let minColumnHead = curNode;
    while (curNode !== head) {
      curNode = curNode.right;
      const length = this.getLinkedListLength(curNode, Direction.vertical) - 1;
      if (length > 0 && min > length) {
        min = length;
        minColumnHead = curNode;
      }
    }
    return minColumnHead;
  }
  getColumnHead(node) {
    let p = node;
    while (p.hasOwnProperty("row")) {
      p = p.down;
    }
    return p;
  }
  getRowHead(node) {
    let p = node;
    while (p.hasOwnProperty("column")) {
      p = p.right;
    }
    return p;
  }
  getColumnIndex(columnHead) {
    let p = this.head;
    let index = -1;
    while (p !== columnHead) {
      p = p.right;
      index++;
    }
    return index;
  }
  getRowIndex(rowHead) {
    let p = this.head;
    let index = -1;
    while (p !== rowHead) {
      p = p.down;
      index++;
    }
    return index;
  }
  showMatrix(head) {
    let p = head.down;
    let res = [];
    while (p !== head) {
      const rowCount = this.getMatrixHeight(head);
      if (rowCount > 0) {
        const row = this.getRow(p);
        res.push(row);
      }
      p = p.down;
    }
    console.log(res);
  }
  showMatrixT(head) {
    let p = head.right;
    let res = [];
    while (p !== head) {
      const columnCount = this.getMatrixWidth(head);
      if (columnCount > 0) {
        const column = this.getColumn(p);
        res.push(column);
      }
      p = p.right;
    }
    console.log(res);
  }
  getLinkedListLength(node, direction) {
    if (!node) {
      return 0;
    }
    let p = node;
    let length = 0;
    while (true) {
      p = direction === Direction.horizontal ? p.right : p.down;
      length++;
      if (p === node) {
        break;
      }
    }
    return length;
  }
  getMatrixWidth(head) {
    return this.getLinkedListLength(head, Direction.horizontal) - 1;
  }
  getMatrixHeight(head) {
    return this.getLinkedListLength(head, Direction.vertical) - 1;
  }
};
var SudoKu = class {
  static build(matrix) {
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        for (let k = 1; k <= 9; k++) {
          const section1 = new Array(81).fill(0);
          section1[i * 9 + j] = 1;
          const section2 = new Array(81).fill(0);
          section2[i * 9 + k - 1] = 1;
          const section3 = new Array(81).fill(0);
          section3[j * 9 + k - 1] = 1;
          const section4 = new Array(81).fill(0);
          section4[(Math.floor(i / 3) + Math.floor(j / 3) * 3) * 9 + k - 1] = 1;
          matrix.push([...section1, ...section2, ...section3, ...section4]);
        }
      }
    }
    return matrix;
  }
  static sudoKu2ExactCoverLine(sudoKu) {
    const section1 = new Array(81).fill(0);
    const section2 = new Array(81).fill(0);
    const section3 = new Array(81).fill(0);
    const section4 = new Array(81).fill(0);
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        const k = sudoKu[i][j];
        if (k > 0 && k <= 9) {
          section1[i * 9 + j] = 1;
          section2[i * 9 + k - 1] = 1;
          section3[j * 9 + k - 1] = 1;
          section4[(Math.floor(i / 3) + Math.floor(j / 3) * 3) * 9 + k - 1] = 1;
        }
      }
    }
    return [...section1, ...section2, ...section3, ...section4];
  }
  static exactCoverMatrix2SudoKuMatrix(matrix, ans, sudoKu) {
    if (!sudoKu) {
      sudoKu = SudoKu.buildEmptySudoKu();
    } else {
      sudoKu = JSON.parse(JSON.stringify(sudoKu));
    }
    for (let i = 1; i < ans.length; i++) {
      const line = matrix[ans[i]];
      let row, column;
      for (let j = 0; j < 81; j++) {
        if (line[j] === 1) {
          row = Math.floor(j / 9);
          column = j % 9;
        }
      }
      let number;
      for (let j = 81 + row * 9; j < 81 + row * 9 + 9; j++) {
        if (line[j] === 1) {
          number = j - 81 - row * 9 + 1;
        }
      }
      if (number > 0) {
        sudoKu[row][column] = number;
      }
    }
    console.log("\u6570\u72EC\u56FE:", JSON.stringify(sudoKu));
    return sudoKu;
  }
  static buildEmptySudoKu() {
    let res = [];
    for (let i = 0; i < 9; i++) {
      res.push(new Array(9).fill(0));
    }
    return res;
  }
  static verify(sudoKu) {
    const arr = SudoKu.sudoKu2ExactCoverLine(sudoKu);
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] !== 1) {
        return false;
      }
    }
    return true;
  }
  static solve(sudoKu) {
    const matrix = [SudoKu.sudoKu2ExactCoverLine(sudoKu)];
    SudoKu.build(matrix);
    const dancingLinks = new DancingLinks(sudoKu).inputMatrix(matrix);
    if (dancingLinks.hasAns) {
      const res = SudoKu.exactCoverMatrix2SudoKuMatrix(
        matrix,
        dancingLinks.ans,
        sudoKu
      );
      if (SudoKu.verify(res)) {
        return res;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  static getCompleteSudoKu() {
    const sudoKu = SudoKu.buildEmptySudoKu();
    for (let i = 0; i < 11; i++) {
      const row = SudoKu.random0To8();
      const column = SudoKu.random0To8();
      sudoKu[row][column] = i % 9 + 1;
    }
    console.log("\u968F\u673A\u56FE\uFF1A", sudoKu);
    const res = SudoKu.solve(sudoKu);
    return res ? res : SudoKu.getCompleteSudoKu();
  }
  static getEasySudoKu() {
    const sudoKu = SudoKu.getCompleteSudoKu();
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (Math.random() > 0.4) {
          sudoKu[i][j] = 0;
        }
      }
    }
    return sudoKu;
  }
  static random0To8() {
    return Math.floor(Math.random() * 9);
  }
};
function test() {
  const testData = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [8, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 5, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 6, 0, 0, 0, 0, 0],
    [0, 0, 0, 4, 0, 0, 0, 0, 0],
    [2, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 7, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 9, 0, 0, 0, 0, 3, 0, 0]
  ];
  SudoKu.solve(testData);
  console.log("\u968F\u673A\u751F\u6210\u4E00\u4E2A\u6570\u72EC:", SudoKu.getEasySudoKu());
}
export {
  SudoKu,
  test
};
//# sourceMappingURL=@liuqinh2s_sudoku-js.js.map
